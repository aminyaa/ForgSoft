#pragma once
#ifndef _threadHandler_Header
#define _threadHandler_Header

#include <FixedList.hxx>
#include <List.hxx>
#include <multiThreader.hxx>

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

namespace tnbLib
{

	/*---------------------------------------------------------------------------*\
							   Class threadHandler Declaration
	\*---------------------------------------------------------------------------*/

	template<class T>
	class threadHandler
	{
		// Reference to the template class
		T& tRef_;

		// Reference to the multiThreader class
		const multiThreader& threader_;

		// List of function argument pointers
		List<void *> argList_;

		// Total number of threads
		const label nThreads_;

		// ID generated by the pthreads API
		pthread_t pthreadID_;

		// Is this a master/slave thread
		mutable bool master_;

		// Synchronization mutexes
		mutable Mutex startMutex_;
		mutable Mutex stopMutex_;

		// Conditionals for synchronization
		mutable Conditional startConditional_;
		mutable Conditional stopConditional_;

		// On some implementations, a conditional wait
		// might return prematurely due to a spurious
		// wake-up signal. Use a predicate to avoid this
		// behaviour.
		mutable FixedList<bool, 2> predicate_;

	public:

		// Enumerants for signalling
		enum signalType
		{
			START,
			STOP
		};

		// Constructor
		threadHandler
		(
			T& tPtr,
			const multiThreader& threader
		);

		// Destructor
		~threadHandler();

		// Return a reference to the template class
		inline T& reference();

		// Set a size for the argument list
		inline void setSize(const label size);

		// Set a argument pointer for a particular index
		inline void set(const label index, void* argPtr);

		// Return a reference to the multiThreader
		inline const multiThreader& threader() const;

		// Return the number of threads
		inline label nThreads() const;

		// Designate as master thread
		inline void setMaster() const;

		// Designate as slave thread
		inline void setSlave() const;

		// Is this a master thread?
		inline bool master() const;

		// Is this a slave thread?
		inline bool slave() const;

		// Lock this thread
		inline void lock(const signalType sType) const;

		// Unlock this thread
		inline void unlock(const signalType sType) const;

		// Send signal to a waiting conditional
		inline void sendSignal(const signalType sType) const;

		// Wait for signal
		inline void waitForSignal(const signalType sType) const;

		// Return state of the predicate variable
		inline bool predicate(const signalType sType) const;

		// Set the predicate variable
		inline void setPredicate(const signalType sType) const;

		// Unset the predicate variable
		inline void unsetPredicate(const signalType sType) const;

		// Set the ID
		inline void setID(const pthread_t& pt);

		// Return the ID
		inline pthread_t ID() const;

		// Does the calling thread correspond to this handler?
		inline bool self() const;

		// Return an argument pointer at a particular index
		inline void * operator()(const label index);
	};


	// Lock all threads provided by sequence
	template <class T>
	void lockThreads
	(
		const List<label>& sequence,
		const PtrList<threadHandler<T>>& handler
	);


	// Synchronize all threads provided by sequence
	template <class T>
	void synchronizeThreads
	(
		const List<label>& sequence,
		const PtrList<threadHandler<T>>& handler
	);


	// Execute threads for the submitted static function by sequence
	template <class T>
	void executeThreads
	(
		const List<label>& sequence,
		PtrList<threadHandler<T>>& handler,
		void(*tFunction)(void*)
	);

	// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

} // End namespace tnbLib

// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //

#include <threadHandlerI.hxx>

#endif // !_threadHandler_Header
